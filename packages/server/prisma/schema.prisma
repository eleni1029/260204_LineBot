generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Customer {
  id            Int         @id @default(autoincrement())
  name          String
  contactPerson String?
  contactEmail  String?
  contactPhone  String?
  notes         String?
  sentiment     Sentiment   @default(NEUTRAL)
  lastContactAt DateTime?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  issues        Issue[]
  groups        LineGroup[]

  @@map("customers")
}

model LineGroup {
  id                  Int           @id @default(autoincrement())
  lineGroupId         String        @unique  // 渠道群組 ID (LINE groupId / Feishu chatId)
  channel             Channel       @default(LINE)  // 渠道類型
  displayName         String?
  status              GroupStatus   @default(ACTIVE)
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
  customerId          Int?
  autoReplyEnabled    Boolean       @default(true)
  knowledgeCategories String[]      @default([])
  members             GroupMember[]
  issues              Issue[]
  customer            Customer?     @relation(fields: [customerId], references: [id])
  messages            Message[]

  @@map("line_groups")
}

model Member {
  id            Int           @id @default(autoincrement())
  lineUserId    String        @unique  // 渠道用戶 ID (LINE userId / Feishu openId)
  channel       Channel       @default(LINE)  // 渠道類型
  displayName   String?
  pictureUrl    String?
  role          MemberRole    @default(EXTERNAL)
  notes         String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  groups        GroupMember[]
  repliedIssues Issue[]       @relation("RepliedBy")
  messages      Message[]

  @@map("members")
}

model GroupMember {
  groupId  Int
  memberId Int
  joinedAt DateTime  @default(now())
  group    LineGroup @relation(fields: [groupId], references: [id])
  member   Member    @relation(fields: [memberId], references: [id])

  @@id([groupId, memberId])
  @@map("group_members")
}

model Message {
  id             Int         @id @default(autoincrement())
  lineMessageId  String?     @unique
  messageType    MessageType @default(TEXT)
  content        String?
  mediaUrl       String?
  rawPayload     Json?
  createdAt      DateTime
  receivedAt     DateTime    @default(now())
  groupId        Int
  memberId       Int
  replyToIssue   Issue?      @relation("ReplyMessage")
  triggeredIssue Issue?      @relation("TriggerMessage")
  group          LineGroup   @relation(fields: [groupId], references: [id])
  member         Member      @relation(fields: [memberId], references: [id])

  @@index([groupId, createdAt(sort: Desc)])
  @@map("messages")
}

model Issue {
  id                  Int                @id @default(autoincrement())
  questionSummary     String?
  status              IssueStatus        @default(PENDING)
  isQuestion          Boolean            @default(true)
  replyRelevanceScore Int?
  sentiment           Sentiment?
  suggestedReply      String?
  createdAt           DateTime           @default(now())
  timeoutAt           DateTime?
  repliedAt           DateTime?
  resolvedAt          DateTime?
  groupId             Int
  customerId          Int?
  triggerMessageId    Int?               @unique
  replyMessageId      Int?               @unique
  repliedById         Int?
  tags                IssueTagRelation[]
  customer            Customer?          @relation(fields: [customerId], references: [id])
  group               LineGroup          @relation(fields: [groupId], references: [id])
  repliedBy           Member?            @relation("RepliedBy", fields: [repliedById], references: [id])
  replyMessage        Message?           @relation("ReplyMessage", fields: [replyMessageId], references: [id])
  triggerMessage      Message?           @relation("TriggerMessage", fields: [triggerMessageId], references: [id])

  @@index([status, createdAt])
  @@index([customerId, status])
  @@map("issues")
}

model IssueTag {
  id          Int                @id @default(autoincrement())
  name        String             @unique
  description String?
  usageCount  Int                @default(0)
  createdAt   DateTime           @default(now())
  issues      IssueTagRelation[]

  @@map("issue_tags")
}

model IssueTagRelation {
  issueId Int
  tagId   Int
  issue   Issue    @relation(fields: [issueId], references: [id])
  tag     IssueTag @relation(fields: [tagId], references: [id])

  @@id([issueId, tagId])
  @@map("issue_tag_relations")
}

model User {
  id               Int              @id @default(autoincrement())
  username         String           @unique
  email            String           @unique
  passwordHash     String
  displayName      String?
  isActive         Boolean          @default(true)
  lastLoginAt      DateTime?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  roleId           Int
  activityLogs     ActivityLog[]
  knowledgeEntries KnowledgeEntry[]
  role             Role             @relation(fields: [roleId], references: [id])

  @@map("users")
}

model Role {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  description String?
  permissions String[]
  isSystem    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  users       User[]

  @@map("roles")
}

model Setting {
  id          Int      @id @default(autoincrement())
  key         String   @unique
  value       String
  description String?
  updatedAt   DateTime @updatedAt

  @@map("settings")
}

model ActivityLog {
  id         Int      @id @default(autoincrement())
  entityType String
  entityId   Int?
  action     String
  details    Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())
  userId     Int?
  user       User?    @relation(fields: [userId], references: [id])

  @@index([entityType, entityId])
  @@index([userId, createdAt(sort: Desc)])
  @@map("activity_logs")
}

model KnowledgeEntry {
  id           Int             @id @default(autoincrement())
  question     String
  answer       String
  category     String?
  keywords     String[]
  source       KnowledgeSource @default(MANUAL)
  sourceRef    String?         // 來源參考（如飛書文檔 ID）
  isActive     Boolean         @default(true)
  isSyncedToAI Boolean         @default(false)
  usageCount   Int             @default(0)
  lastUsedAt   DateTime?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  createdById  Int?
  createdBy    User?           @relation(fields: [createdById], references: [id])

  @@index([isActive, isSyncedToAI])
  @@index([category])
  @@index([source])
  @@map("knowledge_entries")
}

model AutoReplyLog {
  id          Int      @id @default(autoincrement())
  messageId   Int?
  groupId     Int
  memberId    Int
  question    String
  answer      String?
  knowledgeId Int?
  matched     Boolean  @default(false)
  confidence  Float?
  createdAt   DateTime @default(now())

  @@index([matched, createdAt])
  @@map("auto_reply_logs")
}

enum Sentiment {
  POSITIVE
  NEUTRAL
  NEGATIVE
  AT_RISK
}

enum GroupStatus {
  ACTIVE
  ARCHIVED
}

enum MemberRole {
  STAFF
  EXTERNAL_ADMIN
  EXTERNAL
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  FILE
  STICKER
  LOCATION
  OTHER
}

enum IssueStatus {
  PENDING
  REPLIED
  WAITING_CUSTOMER
  TIMEOUT
  RESOLVED
  IGNORED
}

enum Channel {
  LINE
  FEISHU
}

enum KnowledgeSource {
  MANUAL       // 手動新增
  FILE_IMPORT  // 檔案匯入
  FEISHU_SYNC  // 飛書同步
}
